<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SRCD 3D Map</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

<link href="https://api.mapbox.com/mapbox-gl-js/v3.17.0-beta.1/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.17.0-beta.1/mapbox-gl.js"></script>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

<style>
html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
}
#map {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
}
#surfaceCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 2;
}
#layerTogglePanel {
    position: absolute;
    top: 20px;
    left: 20px;
    padding: 8px 10px;
    background: white;
    border-radius: 6px;
    z-index: 10;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    font-family: Arial;
}
#layerTogglePanel label {
    display: block;
    cursor: pointer;
    margin-bottom: 6px;
}
</style>
</head>

<body>
<div id="map"></div>
<canvas id="surfaceCanvas"></canvas>

<div id="layerTogglePanel">
    <label><input type="checkbox" id="toggleSites" checked> Sites</label>
    <label><input type="checkbox" id="toggle3D" checked> 3D Models</label>
    <label><input type="checkbox" id="toggleSurface" checked> Surface Halo</label>
</div>

<script>
mapboxgl.accessToken = "pk.eyJ1Ijoic25iZW5vaSIsImEiOiJjbWg5Y2IweTAwbnRzMm5xMXZrNnFnbmY5In0.Lza9yPTlMhbHE5zHNRb1aA";

const map = new mapboxgl.Map({
    container: "map",
    style: "mapbox://styles/snbenoi/cmhjgr9hh000001rcf6cy38p0",
    center: [-122.5125, 37.9679],
    zoom: 19,
    pitch: 60,
    antialias: true
});

map.on("load", () => {

    const corners = [
        [-122.537464, 37.984078],
        [-122.477353, 37.984108],
        [-122.477370, 37.952203],
        [-122.537475, 37.952208]
    ];

    const surfaceCanvas = document.getElementById("surfaceCanvas");
    const ctx = surfaceCanvas.getContext("2d", { alpha: true });
    const surfaceImg = new Image();
    surfaceImg.src = "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/SRCD%20surface.jpg?raw=1";

    let mouse = { x: -9999, y: -9999 };
    let haloRadius = 140;

    function resizeCanvas() {
        surfaceCanvas.width = map.getContainer().clientWidth;
        surfaceCanvas.height = map.getContainer().clientHeight;
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    map.getCanvasContainer().addEventListener("mousemove", (e) => {
        const r = surfaceCanvas.getBoundingClientRect();
        mouse.x = e.clientX - r.left;
        mouse.y = e.clientY - r.top;
    });

    function projectedRect() {
        return {
            tl: map.project(corners[0]),
            tr: map.project(corners[1]),
            bl: map.project(corners[3])
        };
    }

    function drawSurface() {
        if (!surfaceImg.complete) return;
        const w = surfaceCanvas.width;
        const h = surfaceCanvas.height;
        ctx.clearRect(0, 0, w, h);

        const p = projectedRect();
        const drawW = p.tr.x - p.tl.x;
        const drawH = p.bl.y - p.tl.y;

        ctx.save();
        ctx.translate(p.tl.x, p.tl.y);
        ctx.drawImage(surfaceImg, 0, 0, drawW, drawH);

        ctx.globalCompositeOperation = "destination-out";
        const g = ctx.createRadialGradient(mouse.x, mouse.y, haloRadius * 0.3, mouse.x, mouse.y, haloRadius);
        g.addColorStop(0, "rgba(255,255,255,1)");
        g.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, haloRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function animateCanvas() {
        if (document.getElementById("toggleSurface").checked) drawSurface();
        requestAnimationFrame(animateCanvas);
    }
    animateCanvas();

    fetch("https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/data/619data.geojson?raw=1")
        .then(r => r.json())
        .then(geojson => {

            map.addSource("sites", { type: "geojson", data: geojson });

            map.addLayer({
                id: "sites-points",
                type: "circle",
                source: "sites",
                paint: {
                    "circle-radius": 10,
                    "circle-color": "#ff6600",
                    "circle-stroke-width": 2,
                    "circle-stroke-color": "#000"
                }
            });

            map.on("click", "sites-points", (e) => {
                const f = e.features[0];
                const p = f.properties;
                const html =
                    "<h3>" + p.Title + "</h3>" +
                    "<p>" + p.Description + "</p>" +
                    "<p>Coordinates: " + f.geometry.coordinates.join(", ") + "</p>";
                new mapboxgl.Popup()
                    .setLngLat(f.geometry.coordinates)
                    .setHTML(html)
                    .addTo(map);
            });

            const glbSouth = "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/pond_pack.glb?raw=1";
            const glbNW = "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/bench.glb?raw=1";
            const glbNE = "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/closet.glb?raw=1";

            const feats = geojson.features.slice().sort((a, b) => a.geometry.coordinates[1] - b.geometry.coordinates[1]);
            const south = feats[0];
            const mid = feats[1];
            const north = feats[2];

            const west = mid.geometry.coordinates[0] < north.geometry.coordinates[0] ? mid : north;
            const east = mid.geometry.coordinates[0] > north.geometry.coordinates[0] ? mid : north;

            add3DModel(south, glbSouth, "model-south");
            add3DModel(west, glbNW, "model-west");
            add3DModel(east, glbNE, "model-east");
        });

    function add3DModel(feature, url, id) {
        const pos = feature.geometry.coordinates;
        const mc = mapboxgl.MercatorCoordinate.fromLngLat(pos, 0);

        const transform = {
            x: mc.x,
            y: mc.y,
            z: mc.z,
            scale: mc.meterInMercatorCoordinateUnits() * 4
        };

        const camera = new THREE.Camera();
        const scene = new THREE.Scene();
        const loader = new THREE.GLTFLoader();

        let modelObject = null;

        loader.load(url, (gltf) => {
            modelObject = gltf.scene;
            modelObject.traverse(o => { if (o.isMesh) o.userData.pickable = true; });
            scene.add(modelObject);
        });

        const layer = {
            id: id,
            type: "custom",
            renderingMode: "3d",
            onAdd: function (map, gl) {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: map.getCanvas(),
                    context: gl
                });
                this.renderer.autoClear = false;
            },
            render: function (gl, matrix) {
                if (!modelObject) return;
                const mat = new THREE.Matrix4().fromArray(matrix);
                const mt = new THREE.Matrix4()
                    .makeTranslation(transform.x, transform.y, transform.z)
                    .scale(new THREE.Vector3(transform.scale, -transform.scale, transform.scale));
                camera.projectionMatrix = mat.multiply(mt);
                this.renderer.resetState();
                this.renderer.render(scene, camera);
                map.triggerRepaint();
            }
        };

        map.addLayer(layer);

        map.on("mousemove", (e) => {
            if (!modelObject) return;

            const mouse = new THREE.Vector2(
                (e.point.x / map.getCanvas().width) * 2 - 1,
                -(e.point.y / map.getCanvas().height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                modelObject.traverse(o => {
                    if (o.isMesh) o.material.emissive = new THREE.Color(0xff8800);
                });
            } else {
                modelObject.traverse(o => {
                    if (o.isMesh && o.material.emissive) o.material.emissive = new THREE.Color(0);
                });
            }
        });
    }

    document.getElementById("toggleSites").addEventListener("change", (e) => {
        map.setLayoutProperty("sites-points", "visibility", e.target.checked ? "visible" : "none");
    });

    document.getElementById("toggle3D").addEventListener("change", (e) => {
        const v = e.target.checked ? "visible" : "none";
        ["model-south","model-west","model-east"].forEach(id => {
            if (map.getLayer(id)) map.setLayoutProperty(id, "visibility", v);
        });
    });

    document.getElementById("toggleSurface").addEventListener("change", () => {});
});
</script>

</body>
</html>
