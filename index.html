<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SRCD 3D Map</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

<link href="https://api.mapbox.com/mapbox-gl-js/v3.17.0-beta.1/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.17.0-beta.1/mapbox-gl.js"></script>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

<link rel="stylesheet" href="style.css">
</head>

<body>
<div id="map"></div>
<canvas id="surfaceCanvas"></canvas>

<script>
mapboxgl.accessToken = "pk.eyJ1Ijoic25iZW5vaSIsImEiOiJjbWg5Y2IweTAwbnRzMm5xMXZrNnFnbmY5In0.Lza9yPTlMhbHE5zHNRb1aA";

const map = new mapboxgl.Map({
    container: "map",
    style: "mapbox://styles/snbenoi/cmhjgr9hh000001rcf6cy38p0",
    center: [-122.5125, 37.9679],
    zoom: 21,
    pitch: 60,
    bearing: 0,
    antialias: true
});

map.addControl(
    new mapboxgl.NavigationControl({
        visualizePitch: true,
        showCompass: true
    }),
    "top-right"
);

map.on("load", () => {
    const corners = [
        [-122.537464, 37.984078],
        [-122.477353, 37.984108],
        [-122.477370, 37.952203],
        [-122.537475, 37.952208]
    ];

    const underUrl = "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/SFCD%20underground.jpg";
    const surfaceUrl = "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/SRCD%20surface.jpg";

    map.addSource("under-image", {
        type: "image",
        url: underUrl,
        coordinates: corners
    });

    map.addLayer({
        id: "under-layer",
        type: "raster",
        source: "under-image",
        paint: { "raster-opacity": 1 }
    });

    const surfaceCanvas = document.getElementById("surfaceCanvas");
    const ctx = surfaceCanvas.getContext("2d", { alpha: true });

    const surfaceImg = new Image();
    surfaceImg.crossOrigin = "anonymous";
    surfaceImg.src = surfaceUrl;

    let mouse = { x: -9999, y: -9999 };
    let haloRadius = 100;

    function resizeCanvas() {
        surfaceCanvas.width = map.getContainer().clientWidth;
        surfaceCanvas.height = map.getContainer().clientHeight;
    }

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    map.getCanvasContainer().addEventListener("mousemove", (e) => {
        const rect = surfaceCanvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
    });

    function getScreenCoords() {
        const tl = map.project(corners[0]);
        const tr = map.project(corners[1]);
        const bl = map.project(corners[3]);
        return { tl, tr, bl };
    }

    function drawSurface() {
        if (!surfaceImg.complete) return;

        const w = surfaceCanvas.width;
        const h = surfaceCanvas.height;

        ctx.clearRect(0, 0, w, h);

        const s = getScreenCoords();
        const drawW = s.tr.x - s.tl.x;
        const drawH = s.bl.y - s.tl.y;

        ctx.save();
        ctx.translate(s.tl.x, s.tl.y);
        ctx.drawImage(surfaceImg, 0, 0, drawW, drawH);

        ctx.globalCompositeOperation = "destination-out";
        const g = ctx.createRadialGradient(mouse.x, mouse.y, haloRadius * 0.5, mouse.x, mouse.y, haloRadius);
        g.addColorStop(0, "rgba(255,255,255,1)");
        g.addColorStop(1, "rgba(255,255,255,0)");

        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, haloRadius, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    function animateCanvas() {
        drawSurface();
        requestAnimationFrame(animateCanvas);
    }

    animateCanvas();

    fetch("data/619data.geojson")
        .then(r => r.json())
        .then(geojson => {
            map.addSource("sites", { type: "geojson", data: geojson });

            map.addLayer({
                id: "sites-points",
                type: "circle",
                source: "sites",
                paint: {
                    "circle-radius": 8,
                    "circle-color": "#ff5500",
                    "circle-stroke-width": 2,
                    "circle-stroke-color": "#000000"
                }
            });

            map.on("click", "sites-points", (e) => {
                const f = e.features[0];
                const p = f.properties;

                const html =
                    "<h3>" + p.Title + "</h3>" +
                    "<p>" + p.Description + "</p>" +
                    "<p>Coordinates: " + f.geometry.coordinates[0] + ", " + f.geometry.coordinates[1] + "</p>";

                new mapboxgl.Popup()
                    .setLngLat(f.geometry.coordinates)
                    .setHTML(html)
                    .addTo(map);
            });

            const sorted = [...geojson.features].sort((a, b) => a.geometry.coordinates[1] - b.geometry.coordinates[1]);

            const south = sorted[0];
            const north = sorted[2];

            const mid = sorted[1];

            const northwest = mid.geometry.coordinates[0] < north.geometry.coordinates[0] ? mid : south;
            const northeast = mid.geometry.coordinates[0] > north.geometry.coordinates[0] ? mid : north;

            addModel(south, "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/pond_pack.glb", 1.2);
            addModel(northwest, "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/bench.glb", 1.2);
            addModel(northeast, "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/closet.glb", 1.2);
        });


    function addModel(feature, url, scaleFactor) {
        const lngLat = feature.geometry.coordinates;
        const mc = mapboxgl.MercatorCoordinate.fromLngLat(lngLat, 0);

        const transform = {
            translateX: mc.x,
            translateY: mc.y,
            translateZ: mc.z,
            rotateX: Math.PI / 2,
            rotateY: 0,
            rotateZ: 0,
            scale: mc.meterInMercatorCoordinateUnits() * scaleFactor
        };

        const camera = new THREE.Camera();
        const scene = new THREE.Scene();

        const light1 = new THREE.DirectionalLight(0xffffff);
        light1.position.set(0, -70, 100).normalize();
        scene.add(light1);

        const light2 = new THREE.DirectionalLight(0xffffff);
        light2.position.set(0, 70, 100).normalize();
        scene.add(light2);

        const loader = new THREE.GLTFLoader();
        loader.load(url, (gltf) => {
            scene.add(gltf.scene);
        });

        const customLayer = {
            id: "model-" + feature.properties.ID,
            type: "custom",
            renderingMode: "3d",
            onAdd: function (map, gl) {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: map.getCanvas(),
                    context: gl,
                    antialias: true
                });
                this.renderer.autoClear = false;
            },
            render: function (gl, matrix) {
                const rx = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), transform.rotateX);
                const ry = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), transform.rotateY);
                const rz = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 0, 1), transform.rotateZ);

                const m = new THREE.Matrix4().fromArray(matrix);

                const l = new THREE.Matrix4()
                    .makeTranslation(transform.translateX, transform.translateY, transform.translateZ)
                    .scale(new THREE.Vector3(transform.scale, -transform.scale, transform.scale))
                    .multiply(rx)
                    .multiply(ry)
                    .multiply(rz);

                camera.projectionMatrix = m.multiply(l);

                this.renderer.resetState();
                this.renderer.render(scene, camera);

                map.triggerRepaint();
            }
        };

        map.addLayer(customLayer);
    }
});
</script>

</body>
</html>
