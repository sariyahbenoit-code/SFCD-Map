<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SRCD 3D Map</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

<link href="https://api.mapbox.com/mapbox-gl-js/v3.17.0-beta.1/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.17.0-beta.1/mapbox-gl.js"></script>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

<style>
html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: transparent;
    font-family: Arial, sans-serif;
}
#map {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
}
#surfaceCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 2;
}
.mapboxgl-popup {
    z-index: 8;
    max-width: 300px;
}
</style>
</head>

<body>
<div id="map"></div>
<canvas id="surfaceCanvas"></canvas>

<script>
mapboxgl.accessToken = "pk.eyJ1Ijoic25iZW5vaSIsImEiOiJjbWg5Y2IweTAwbnRzMm5xMXZrNnFnbmY5In0.Lza9yPTlMhbHE5zHNRb1aA";

const map = new mapboxgl.Map({
    container: "map",
    style: "mapbox://styles/snbenoi/cmhjgr9hh000001rcf6cy38p0",
    center: [-122.5125, 37.9679],
    zoom: 19,
    pitch: 60,
    bearing: 0,
    antialias: true
});

map.on("load", () => {
    const corners = [
        [-122.537464, 37.984078],
        [-122.477353, 37.984108],
        [-122.477370, 37.952203],
        [-122.537475, 37.952208]
    ];

    const underUrl = "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/SFCD%20underground.jpg?raw=1";
    const surfaceUrl = "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/SRCD%20surface.jpg?raw=1";

    map.addSource("under-image", {
        type: "image",
        url: underUrl,
        coordinates: corners
    });

    map.addLayer({
        id: "under-layer",
        type: "raster",
        source: "under-image"
    });

    const surfaceCanvas = document.getElementById("surfaceCanvas");
    const ctx = surfaceCanvas.getContext("2d", { alpha: true });

    const surfaceImg = new Image();
    surfaceImg.crossOrigin = "anonymous";
    surfaceImg.src = surfaceUrl;

    let mouse = { x: -9999, y: -9999 };
    let haloRadius = 120;

    function resizeCanvas() {
        surfaceCanvas.width = map.getContainer().clientWidth;
        surfaceCanvas.height = map.getContainer().clientHeight;
    }

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    map.getCanvasContainer().addEventListener("mousemove", (e) => {
        const rect = surfaceCanvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
    });

    function getScreenCoords() {
        const tl = map.project(corners[0]);
        const tr = map.project(corners[1]);
        const bl = map.project(corners[3]);
        return { tl, tr, bl };
    }

    function drawSurface() {
        if (!surfaceImg.complete) return;

        const w = surfaceCanvas.width;
        const h = surfaceCanvas.height;

        ctx.clearRect(0, 0, w, h);

        const s = getScreenCoords();
        const drawW = s.tr.x - s.tl.x;
        const drawH = s.bl.y - s.tl.y;

        ctx.save();
        ctx.translate(s.tl.x, s.tl.y);
        ctx.drawImage(surfaceImg, 0, 0, drawW, drawH);

        ctx.globalCompositeOperation = "destination-out";
        const g = ctx.createRadialGradient(mouse.x, mouse.y, haloRadius * 0.3, mouse.x, mouse.y, haloRadius);
        g.addColorStop(0, "rgba(255,255,255,1)");
        g.addColorStop(1, "rgba(255,255,255,0)");

        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, haloRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function animateCanvas() {
        drawSurface();
        requestAnimationFrame(animateCanvas);
    }
    animateCanvas();

    fetch("https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/data/619data.geojson?raw=1")
        .then(r => r.json())
        .then(geojson => {
            map.addSource("sites", { type: "geojson", data: geojson });

            map.addLayer({
                id: "sites-points",
                type: "circle",
                source: "sites",
                paint: {
                    "circle-radius": 10,
                    "circle-color": "#ff6600"
                }
            });

            map.on("click", "sites-points", (e) => {
                const f = e.features[0];
                const p = f.properties;

                const html =
                    "<h3>" + p.Title + "</h3>" +
                    "<p>" + p.Description + "</p>" +
                    "<p>Coordinates: " + f.geometry.coordinates.join(", ") + "</p>";

                new mapboxgl.Popup()
                    .setLngLat(f.geometry.coordinates)
                    .setHTML(html)
                    .addTo(map);
            });

            const feats = geojson.features;
            const sorted = [...feats].sort((a, b) => a.geometry.coordinates[1] - b.geometry.coordinates[1]);

            const south = sorted[0];
            const north = sorted[2];
            const mid = sorted[1];

            const northwest = mid.geometry.coordinates[0] < north.geometry.coordinates[0] ? mid : south;
            const northeast = mid.geometry.coordinates[0] > north.geometry.coordinates[0] ? mid : north;

            addModel(south, "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/pond_pack.glb?raw=1", 4);
            addModel(northwest, "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/bench.glb?raw=1", 4);
            addModel(northeast, "https://raw.githubusercontent.com/sariyahbenoit-code/SRCD-Map/main/assets/images/closet.glb?raw=1", 4);
        });

    function addModel(feature, url, scaleFactor) {
        const lngLat = feature.geometry.coordinates;
        const mc = mapboxgl.MercatorCoordinate.fromLngLat(lngLat, 0);

        const transform = {
            translateX: mc.x,
            translateY: mc.y,
            translateZ: mc.z,
            scale: mc.meterInMercatorCoordinateUnits() * scaleFactor
        };

        const camera = new THREE.Camera();
        const scene = new THREE.Scene();

        const lightA = new THREE.DirectionalLight(0xffffff, 2);
        lightA.position.set(0, 0, 200);
        scene.add(lightA);

        const loader = new THREE.GLTFLoader();
        loader.load(url, (gltf) => {
            gltf.scene.scale.set(1, 1, 1);
            scene.add(gltf.scene);
        });

        const customLayer = {
            id: "model-" + Math.random(),
            type: "custom",
            renderingMode: "3d",
            onAdd: function (map, gl) {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: map.getCanvas(),
                    context: gl,
                    antialias: true
                });
                this.renderer.autoClear = false;
            },
            render: function (gl, matrix) {
                const m = new THREE.Matrix4().fromArray(matrix);
                const t = new THREE.Matrix4()
                    .makeTranslation(transform.translateX, transform.translateY, transform.translateZ)
                    .scale(new THREE.Vector3(transform.scale, -transform.scale, transform.scale));
                camera.projectionMatrix = m.multiply(t);
                this.renderer.resetState();
                this.renderer.render(scene, camera);
                map.triggerRepaint();
            }
        };

        map.addLayer(customLayer);
    }
});
</script>
</body>
</html>
